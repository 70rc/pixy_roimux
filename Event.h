//
// Created by damian on 6/3/17.
//

#ifndef PIXY_ROIMUX_EVENT_H
#define PIXY_ROIMUX_EVENT_H


#include <map>
#include <vector>


namespace pixy_roimux {
    /// \brief 2D hit struct.
    ///
    /// Used to store pixel and ROI hits.
    struct Hit2d {
        /// \brief Pixel channel.
        unsigned channel;

        /// \brief Index in the raw histogram of the first sample of the pulse.
        unsigned firstSample;

        /// \brief Index in the raw histogram of the positive peak sample of the pulse.
        unsigned posPeakSample;

        /// \brief Index in the raw histogram of the first negative sample of the pulse.
        unsigned zeroCrossSample;

        /// \brief Index in the raw histogram of the negative peak sample of the pulse.
        unsigned negPeakSample;

        /// \brief Index in the raw histogram of the last sample of the pulse.
        unsigned lastSample;

        /// \brief Positive pulse width in number of samples.
        unsigned posPulseWidth;

        /// \brief Negative pulse width in number of samples.
        unsigned negPulseWidth;

        /// \brief ADC value at the positive peak of the pulse.
        int posPulseHeight;

        /// \brief ADC value at the negative peak of the pulse.
        int negPulseHeight;

        /// \brief Integral of the pulse from firstSample until and including lastSample.
        ///
        /// In ADC units times number of samples.
        int pulseIntegral;

        /// \brief Raw pulse data extracted from histogram from firstSample until and including lastSample.
        ///
        /// Size is equal to pulseWidth.
        std::vector<int> pulseRaw;
    };


    /// \brief 3D hit struct.
    ///
    /// Used to store 3D hit (candidates).
    struct Hit3d {
        /// \brief X coordinate in cm.
        float x;

        /// \brief Y coordinate in cm.
        float y;

        /// \brief Z coordinate in cm.
        float z;

        /// \brief Integrated charge in fC.
        float chargeInt;

        /// \brief Peak charge in fC.
        float chargePeak;

        /// \brief ID of the corresponding pixel hit.
        unsigned pixelHitId;

        /// \brief ID of the corresponding ROI hit.
        unsigned roiHitId;
    };

    /// \brief Struct storing the data generated by the pricinpal component analysis.
    struct PrincipalComponents {

        /// \brief Number of hits used.
        unsigned numHitsUsed;

        /// \brief Eigen values of the corresponding eigen vectors.
        ///
        /// Sorted by magnitude from highest to lowest.
        std::vector<double> eigenValues;

        /// \brief Eigen vectors forming an orthogonal basis of the 3D space point cloud.
        ///
        /// Sorted according to the corresponding eigen values.
        std::vector<std::vector<double>> eigenVectors;

        /// \brief Average position of the 3D space point cloud.
        std::vector<double> avePosition;

        /// \brief Average distance of closest approach of all hits to the eigen vector with the highest eigen value.
        double aveHitDoca;
    };


    /// \brief Event struct.
    ///
    /// The lead(trail) multimaps map the leading(trailing) edge of the hit pulse to the hit in pixelHits and roiHits
    /// respectively. The pixel2roi(roi2pixel) vectors map each pixel(roi) hit to all its matched roi(pixel) hits, i.e.
    /// pixel2roi.at(x) will return a vector containing the indices of all the hits in roiHits matched to the x-th
    /// pixelHit. If an ambiguous match occured, the vector will contain more than one index. If matching failed, the
    /// vector will be empty.
    struct Event {
        /// \brief Run ID.
        unsigned runId;

        /// \brief Subrun ID.
        unsigned subrunId;

        /// \brief Event ID.
        unsigned eventId;

        /// \brief Pixel hits stored in Hit2d structs.
        std::vector<Hit2d> pixelHits;

        /// \brief Map from Hit2d.firstSample to its index in pixelHits.
        ///
        /// Ordered by leading pulse edge.
        std::multimap<unsigned, unsigned> pixelHitOrderLead;

        /// \brief Map from Hit2d.lastSample to its index in pixelHits.
        ///
        /// Ordered by trailing pulse edge.
        std::multimap<unsigned, unsigned> pixelHitOrderTrail;

        /// \brief ROI hits stored in Hit2d structs.
        std::vector<Hit2d> roiHits;

        /// \brief Map from Hit2d.firstSample to its index in roiHits.
        ///
        /// Ordered by leading pulse edge.
        std::multimap<unsigned, unsigned> roiHitOrderLead;

        /// \brief Map from Hit2d.lastSample to its index in roiHits.
        ///
        /// Ordered by trailing pulse edge.
        std::multimap<unsigned, unsigned> roiHitOrderTrail;

        /// \brief Vector of indices of all matched roiHits for each pixelHit entry.
        std::vector<std::vector<unsigned>> pixel2roi;

        /// \brief Vector of indices of all matched pixelHits for each roiHit entry.
        std::vector<std::vector<unsigned>> roi2pixel;

        /// \brief Hit3d candidates generated from pixel2roi and pixelHits.
        ///
        /// Has the same dimensions as pixel2roi.
        std::vector<std::vector<Hit3d>> hitCandidates;

        /// \brief Used by the principal component analysis to treat ambiguities.
        std::vector<int> pcaIds;

        /// \brief Principal components analysis data.
        PrincipalComponents principalComponents;
    };
}



#endif //PIXY_ROIMUX_EVENT_H
